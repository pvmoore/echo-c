module ec.gen.StmtGenerator;

import ec.all;
import std.file : write;

final class StmtGenerator {
public:
    void generate(CFile cfile) {
        log("Generating %s", cfile.filename);
        buf = new StringBuffer();

        buf.add("/*\n");
        buf.add("  Generated by EC\n");
        buf.add("\n");
        buf.add("  Original file: %s\n", cfile.filename);
        buf.add("*/\n\n");

        // buf.add("//__ec_ignore_start__\n");
        // buf.add("#if __STDC_VERSION__ < 202311L // C23\n");
        // buf.add("#include <stdbool.h>\n");
        // buf.add("#endif // C23\n");
        // buf.add("//__ec_ignore_end__\n");

        foreach(ch; cfile.children) {
            
            if(Stmt stmt = ch.as!Stmt) {
                if(stmt.location.originalFilenameIndex != originalFilenameIndex) {
                    originalFilenameIndex = stmt.location.originalFilenameIndex;
                    buf.add("\n// Original file: %s\n\n", stmt.location.originalFilename());
                }
                generate(stmt);
                endStmt(stmt);
            } else if(Type t = ch.as!Type) {
                generate(t);
                endStmt(t);
                newLine();
            } else assert(false, "Expected Stmt or Type, got %s".format(ch));
        }

        string outFile = cfile.config.targetDirectory ~ cfile.filename;
        write(outFile, buf.toString());
    }
private:
    StringBuffer buf;
    string indent;
    int originalFilenameIndex = -1;

    void endStmt(Node n) {
        EStmt estmt = n.isA!Stmt ? n.as!Stmt.estmt : EStmt.UNKNOWN;
        bool addLineComment = n.parent.isA!CFile && n.isA!Stmt;
        bool addNewLine = true;
        bool isBlockStmt = estmt.isOneOf(
            EStmt.SCOPE, EStmt.FUNC, EStmt.IF, EStmt.FOR, EStmt.WHILE, EStmt.SWITCH
        );
        if(auto func = n.as!Function) {
            isBlockStmt = func.hasBody;
        }
        bool semicolon = !isBlockStmt && !estmt.isOneOf(EStmt.LABEL, EStmt.PRAGMA);

        if(Var v = n.as!Var) {
            addLineComment = v.isGlobal() && !v.inList;
            addNewLine = !v.inList || v.lastInList;
            semicolon = !v.inList || v.lastInList;
        } 
        if(Typedef td = n.as!Typedef) {
            addLineComment = !td.inList || td.lastInList;
            addNewLine = !td.inList || td.lastInList;
            semicolon = !td.inList || td.lastInList;
        }

        if(semicolon) {
            buf.add(";");
        }
        if(addLineComment) {
            auto stmt = n.as!Stmt; assert(stmt);
            buf.add("  // line %s (orig %s)\n", stmt.location.line, stmt.location.originalLine);
        }
        if(addNewLine) {
            newLine();
        }
    }
    void newLine() {
        buf.add("\n%s", indent);
    }
    void openScope(bool brace = true) {
        buf.add(" ");
        if(brace) buf.add("{");
        indent ~= "    ";
        newLine();
    }
    void closeScope(bool brace = true) in {
        assert(indent.length >= 4);
        assert(buf.length >= 4);
        assert(buf[$-4..$] == "    ");
    } do {
        indent.length -= 4;
        buf.sub(4);
        if(brace) buf.add("}");
    }

    void generate(Stmt stmt) {
        //buf.add("/* %s */", stmt.estmt);
        log("generate %s %s", stmt.estmt, stmt);
        switch(stmt.estmt) {
            case EStmt.ADDRESSOF: generate(stmt.as!Addressof); break;
            case EStmt.BREAK: generate(stmt.as!Break); break;
            case EStmt.CALL: generateCall(stmt.as!Call); break;
            case EStmt.CAST: generate(stmt.as!Cast); break;
            case EStmt.CONTINUE: generate(stmt.as!Continue); break;
            case EStmt.DOT: generate(stmt.as!Dot); break;
            case EStmt.DO_WHILE: generate(stmt.as!DoWhile); break;
            case EStmt.ENUM: generate(stmt.as!Enum); break;
            case EStmt.PARENS: generate(stmt.as!Parens); break;
            case EStmt.IDENTIFIER: generate(stmt.as!Identifier); break;
            case EStmt.IF: generate(stmt.as!If); break;
            case EStmt.INDEX: generate(stmt.as!Index); break;
            case EStmt.INFIX: generate(stmt.as!Infix); break; 
            case EStmt.INITIALISER: generate(stmt.as!Initialiser); break;
            case EStmt.LABEL: generate(stmt.as!Label); break;
            case EStmt.FOR: generate(stmt.as!For); break;
            case EStmt.FUNC: generate(stmt.as!Function); break;
            case EStmt.NUMBER: generate(stmt.as!Number); break;
            case EStmt.PRAGMA: generate(stmt.as!Pragma); break;
            case EStmt.PREFIX: generate(stmt.as!Prefix); break;
            case EStmt.POSTFIX: generate(stmt.as!Postfix); break;
            case EStmt.RETURN: generate(stmt.as!Return); break;
            case EStmt.SCOPE: generate(stmt.as!Scope); break;
            case EStmt.STRING_LITERAL: generate(stmt.as!StringLiteral); break;
            case EStmt.STRUCT: generate(stmt.as!Struct); break;
            case EStmt.SWITCH: generate(stmt.as!Switch); break;
            case EStmt.TERNARY: generate(stmt.as!Ternary); break;
            case EStmt.TYPEDEF: generate(stmt.as!Typedef); break;
            case EStmt.UNION: generate(stmt.as!Union); break;
            case EStmt.VAR: generate(stmt.as!Var); break;
            case EStmt.VALUEOF: generate(stmt.as!Valueof); break;
            case EStmt.WHILE: generate(stmt.as!While); break;
            default: todo("generate: implement %s".format(stmt.estmt));
        }
    }
    void generate(Type type) {
        if(TypeRef tr = type.as!TypeRef) {
            generate(tr);
        } else if(SimpleType st = type.as!SimpleType) {
            generate(st);
        } else if(FunctionPtr fp = type.as!FunctionPtr) {
            generate(fp);
        } else if(ArrayType at = type.as!ArrayType) {
            generate(at);
        } else {
            todo("generate(Type): implement %s".format(type.etype));
        }
    }

    void generate(Addressof addr) {
        buf.add("&");
        generate(addr.expr());
    }
    void generate(Break b) {
        buf.add("break");
    }
    void generateCall(Call call) {
        buf.add("%s(", call.name);
        foreach(i, arg; call.args) {
            if(i > 0) buf.add(", ");
            generate(arg);
        }
        buf.add(")");
    }
    void generate(Cast c) {
        buf.add("(");
        generate(c.type);
        buf.add(") ");
        generate(c.expr());
    }
    void generate(Continue c) {
        buf.add("continue");
    }
    void generate(Dot d) {
        generate(d.left());
        buf.add(d.isArrow ? "->" : ".");
        generate(d.right());
    }
    void generate(DoWhile dw) {
        buf.add("do");
        openScope();

        foreach(s; dw.body()) {
            generate(s);
            endStmt(s);
        }
        closeScope();

        buf.add("while(");
        generate(dw.condition());
        buf.add(")");
    }
    void generate(For f) {
        buf.add("for(");

        // init
        foreach(i, s; f.initVars()) {
            generate(s);
        }
        buf.add("; ");

        // condition
        generate(f.condition());
        buf.add("; ");

        // post
        foreach(i, s; f.postExprs()) {
            if(i > 0) buf.add(", ");
            generate(s);
        }
        buf.add(")");

        // body
        openScope();
        foreach(s; f.body()) {
            generate(s);
            endStmt(s);
        }
        closeScope();
    }
    void generate(Function func) {
        string cc = stringOf(func.callingConvention);
        string sc = func.storageClass.toString();
        buf.add("%s%s %s%s(", sc, func.returnType, cc, func.name);
        foreach(i, p; func.params()) {
            if(i > 0) buf.add(", ");
            generate(p);
        }
        buf.add(")");

        if(func.hasBody) {
            openScope();

            foreach(s; func.body()) {
                if(s.isA!Label) {
                    buf.sub(indent.length.as!int);
                }
                generate(s);
                endStmt(s);
            }
            closeScope();
        } 
    }
    void generate(Identifier id) {
        buf.add(id.name);
    }
    void generate(If if_) {
        buf.add("if(");
        generate(if_.condition());
        buf.add(")");

        openScope(if_.hasThenBraces);

        foreach(s; if_.thenStmts()) {
            generate(s);
            endStmt(s);
        }
        closeScope(if_.hasThenBraces);

        if(if_.hasElse()) {
            buf.add(" else");
            openScope(if_.hasElseBraces);

            foreach(s; if_.elseStmts()) {
                generate(s);
                endStmt(s);
            }
            closeScope(if_.hasElseBraces);
        }
    }
    void generate(Index i) {
        generate(i.pointer());

        foreach(e; i.exprs()) {
            buf.add("[");
            generate(e);
            buf.add("]");
        }
    }
    void generate(Infix infix) {
        generate(infix.left());
        buf.add(" %s ", infix.op.stringOf());
        generate(infix.right());
    }
    void generate(Initialiser init) {
        buf.add("{");
        Expr[] exprs = init.exprs();
        foreach(i, e; init.elements) {
            if(i > 0) buf.add(", ");
            final switch(e.kind) {
                case Initialiser.ElementKind.EXPR:
                    generate(exprs[e.exprIndex]);
                    break;
                case Initialiser.ElementKind.LABEL_EXPR:
                    buf.add(".%s = ", e.label);
                    generate(exprs[e.exprIndex]);
                    break;
                case Initialiser.ElementKind.INDEX_EXPR:
                    buf.add("[");
                    generate(exprs[e.arrayIndex]);
                    buf.add("] = ");
                    generate(exprs[e.exprIndex]);
                    break;
            }
        }
        buf.add("}");
    }
    void generate(Label l) {
        buf.add("%s:", l.name);
    }
    void generate(Number n) {
        buf.add("%s", n.stringValue);
    }
    void generate(Parens p) {
        buf.add("(");
        generate(p.expr());
        buf.add(")");
    }
    void generate(Pragma pragma_) {
        buf.add("#pragma ");
        switch(pragma_.kind) {
            case Pragma.PragmaKind.WARNING: 
                buf.add("warning(");
                foreach(i, w; pragma_.data.warnings) {
                    if(i > 0) buf.add("; ");

                    if(w.push) {
                        buf.add("push");
                        if(w.level > 0) buf.add(", %s", w.level);
                    } else if(w.pop) {
                        buf.add("pop");
                    } else {
                        buf.add("%s : %s", w.specifier, w.numbers.join(" "));
                    }
                }
                buf.add(")");
                break;
            case Pragma.PragmaKind.PACK: {
                auto pack = pragma_.data.pack;
                buf.add("pack(");
                if(pack.isPush && pack.n > 0) {
                    buf.add("push, %s", pack.n);
                } else if(pack.isPush && pack.n == 0) {
                    buf.add("push");
                } else if(pack.isPop) {
                    buf.add("pop");
                } else {
                    buf.add("%s", pack.n);
                }
                buf.add(")");
                break;
            }
            case Pragma.PragmaKind.INTRINSIC: {
                auto i = pragma_.data.intrinsic;
                buf.add("intrinsic(%s)", i.funcnames.join(", "));
                break;
            }
            default: todo("generate(Pragma): implement %s".format(pragma_.kind));
        }
    }
    void generate(Postfix p) {
        generate(p.expr());
        buf.add("%s", p.op.stringOf());
    }
    void generate(Prefix p) {
        buf.add("%s", p.op.stringOf());
        generate(p.expr());
    }
    void generate(Return r) {
        buf.add("return");
        if(r.hasExpr()) {
            buf.add(" ");
            generate(r.expr());
        }
    }
    void generate(Scope s) {
        openScope();

        foreach(st; s.stmts()) {
            generate(st);
            endStmt(st);
        }
        closeScope();
    }
    void generate(StringLiteral s) {
        foreach(i, lit; s.values) {
            if(i > 0) buf.add(" ");
            buf.add("%s", lit);
        }
    }
    void generate(Switch s) {
        buf.add("switch(");
        generate(s.condition());
        buf.add(")");
        openScope();

        foreach(i, c; s.cases) {
            auto start = c.childIndex;
            auto end = i == s.cases.length-1 ? s.numChildren() : s.cases[i+1].childIndex;

            if(c.isDefault) {
                buf.add("default: ");
            } else {
                buf.add("case ");
                generate(s.children[c.childIndex].as!Expr);
                buf.add(": ");
                start++;
            }
            string ind = indent;
            indent ~= "    ";
            newLine();

            foreach(j, st; s.children[start..end]) {
                generate(st.as!Stmt);
                endStmt(st);
            }
            indent = ind;
            buf.sub(4);
        }
        closeScope();
    }
    void generate(Ternary t) {
        generate(t.condition());
        buf.add(" ? ");
        generate(t.trueExpr());
        buf.add(" : ");
        generate(t.falseExpr());
    }

    void generate(Typedef td) {

        // Generate the type if this Typedef is on its own or it is the first of many in the same stmt
        if(!td.inList || td.firstInList) {
            buf.add("typedef ");
            generate(td.type);
        }
        // Add a comma and ptr if this is a subsequent Typedef in a list
        if(td.inList && !td.firstInList) {
            buf.add(",%s", td.type.getPtrString());
        }

        if(!td.nameIsEmbedded) {
            buf.add(" %s", td.name);
        }
    }
    void generate(Valueof v) {
        buf.add("*");
        generate(v.expr());
    }
    void generate(Var var) {
        buf.add("%s", var.storageClass);

        // Generate the type if this Var is on its own or it is the first of many in the same stmt
        if(!var.inList || var.firstInList) {
            generate(var.type);
        }
        // Add a comma and ptr if this is a subsequent Var in a list
        if(var.inList && !var.firstInList) {
            buf.add(",%s", var.type.getPtrString());
        } 

        if(var.type.isA!ArrayType) {
            // If this is an array type, we will generate the var name and dimensions later
            // so we don't add it here
        } else if(var.name) {
            buf.add(" %s", var.name);
        }

        if(var.hasBitfield) {
            buf.add(" : ");
            generate(var.bitfield());
        }
        
        if(var.hasInitialiser) {
            buf.add(" = ");
            generate(var.initialiser());
        }
    }
    void generate(While w) {
        buf.add("while(");
        generate(w.condition());
        buf.add(")");
        openScope();

        foreach(s; w.body()) {
            generate(s);
            endStmt(s);
        }
        closeScope();
    }

    //──────────────────────────────────────────────────────────────────────────────────────────────────
    // Type generation below here
    //──────────────────────────────────────────────────────────────────────────────────────────────────

    // Note that this will also generate the var name if there is one
    void generate(ArrayType at) {
        generate(at.elementType);
        if(at.varName) {
            buf.add(" %s", at.varName);
        }
        foreach(d; at.dimensionExprs()) {
            buf.add("[");
            auto num = d.as!Number;
            if(num && "-1" == num.stringValue) {
                // this is an empty dimension
            } else {
                generate(d);
            }
            buf.add("]");
        }
    }
    // Note that this will also generate the var name if there is one
    void generate(FunctionPtr fp) {
        generate(fp.returnType);
        string cc = stringOf(fp.callingConvention);
        buf.add("(%s%s %s)(", cc, fp.getPtrString(), fp.varName);

        foreach(i, p; fp.params) {
            if(i > 0) buf.add(", ");
            generate(p);
        }
        buf.add(")");
    }
    void generate(SimpleType s) {
        buf.add("%s", s.toString());
    }
    void generate(Struct s) {
        buf.add("struct %s", s.name);

        if(s.hasBody) {
            openScope();

            foreach(m; s.body()) {
                generate(m);
                endStmt(m);
            }
            closeScope();
        }
    }
    void generate(Union u) {
        buf.add("union %s", u.name);

        if(u.hasBody) {
            openScope();

            foreach(m; u.body()) {
                generate(m);
                endStmt(m);
            }
            closeScope();
        }
    }
    void generate(Enum e) {
        buf.add("enum %s", e.name);

        if(e.hasBody) {
            openScope();

            foreach(i, m; e.members) {
                buf.add("%s", m.label);
                if(m.exprIndex != -1) {
                    buf.add(" = ");
                    generate(e.children[m.exprIndex].as!Expr);
                } 
                if(i != e.members.length - 1) {
                    buf.add(",");
                }
                newLine();
            }
            closeScope();
        }
    }
    void generate(TypeRef tr) {
        if(tr.hasChildren()) {
            buf.add("%s", tr.modifiers);
            generate(tr.first().as!Stmt);
            buf.add("%s", tr.getPtrString());
        } else {
            
            buf.add(tr.toString());
        }
    }
}
